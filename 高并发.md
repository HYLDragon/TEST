
## java并行
- 1.线程的两种写法
    - 1.继承Thread (com.zx.mes.thread.Mythread)
    - 2.实现Runable接口 (com.zx.mes.thread.MythreadWithRunable)
    - 3.用volatile修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值。
    volatile很容易被误用，用来进行原子性操作。
    对于volatile修饰的变量，jvm虚拟机只是保证从主内存加载到线程工作内存的值是最新的
- 2.关于线程的中断
    - 1.com.zx.mes.test.thread.Test类有详细的测试
    - 2.注意死锁状态线程是无法被中断的，例如同步锁synchronized 
    - 3.suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，
    必须其对应的 resume() 被调用，才能使得线程重新进入可执行状态;
    但suspend()方法很容易引起死锁问题， 已经不推荐使用了。
    - 4.wait, notify 和 notifyAll,不要在Thread中使用
    基于以上认知，下面这个是使用wait和notify函数的规范代码模板：
        ```
        // The standard idiom for calling the wait method in Java 
        synchronized (sharedObject) { 
            while (condition) { 
            sharedObject.wait(); 
                // (Releases lock, and reacquires on wakeup) 
            } 
            // do action based upon condition e.g. take or put into queue 
        }
        ```
     - 5.Yield是一个静态的原生(native)方法
         Yield告诉当前正在执行的线程把运行机会交给线程池中拥有相同优先级的线程。
         Yield不能保证使得当前正在运行的线程迅速转换到可运行的状态
         它仅能使一个线程从运行状态转到可运行状态，而不是等待或阻塞状态



